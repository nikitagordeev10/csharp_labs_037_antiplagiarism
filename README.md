# Платформа: ulearn
## Курс: Основы программирования
### Тема: 28 Динамическое программирование
#### Практика «Антиплагиат» | «Diff Tool»
##### Решено 11 ноября 2023 в 12:23

ИТ-компания К. приглашает студентов на летнюю стажировку. Чтобы попасть на стажировку, претенденты решают тестовое задание — задачу на программирование вроде тех, что есть в этом курсе, только сложнее.

Из года в год претенденты присылают несколько сотен решений. Можно ли как-то автоматически найти среди них «списанные» решения, то есть такие, которые слишком сильно похожи друг на друга?

Оказывается расстояние Левенштейна можно использовать для того, чтобы сравнивать листинги программ (или вообще любые документы) друг с другом и находить самые похожие пары. 

Реализуем класс LevenshteinCalculator, который получает на вход список документов и возвращает список попарных сравнений каждого документа с каждым другим.

Мы хотим, чтобы разница в пробелах, пустых строках или небольшом переименовании переменных не сбивала наш алгоритм. Поэтому нужно реализовать модифицированный алгоритм Левенштейна:

Он должен анализировать не последовательности символов, а последовательности токенов — лексических единиц. Например, в коде force = mass * acceleration 5 токенов: force, =, mass, *, acceleration. Код разбиения на токены уже реализован и на вход алгоритму поступает список токенов. Один документ представляется типом DocumentTokens (который объявлен, как синоним List<string>).

Если два токена различаются, то будем учитывать ещё степень различия. Стоимость замены одного токена на другой в алгоритме Левенштейна будем вычислять с помощью формулы коэффициента Жаккара. Она тоже реализована в методе GetTokenDistance класса TokenDistanceCalculator. Стоимость удаления/добавления токена равна единице, как и в оригинальном алгоритме.

Предстоит проанализировать два документа и найти в них повторяющиеся части. Подобную задачу решают так называемые Diff Tools — инструменты для сравнения текстовых файлов.

Нужен алгоритм, который будет по двум последовательностям токенов возвращать их наибольшую общую подпоследовательность. Она должна состоять из токенов первой последовательности, которые в том же порядке присутствуют и во второй последовательности (токены не обязательно должны идти подряд). И из всех таких последовательностей вернуть нужно самую длинную. Если самых длинных несколько, можно вернуть любую.

Например, у документов a1 b2 ab1 b21 b2 и b2 b2 a1 (токены разделены пробелом) наибольшая общая подпоследовательность — это b2 b2 и имеет длину 2 токена.

Реализуем это в методе Calculate в классе LongestCommonSubsequenceCalculator и отладьте реализацию на тестах LongestCommonSubsequenceCalculator_Tests. 

